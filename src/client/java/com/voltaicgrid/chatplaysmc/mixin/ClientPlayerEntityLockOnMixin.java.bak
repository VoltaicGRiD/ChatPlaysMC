package com.voltaicgrid.chatplaysmc.mixin;

import com.voltaicgrid.chatplaysmc.client.LockOnManager;
import net.minecraft.client.world.ClientWorld;
import net.minecraft.entity.Entity;
import net.minecraft.entity.LivingEntity;
import net.minecraft.text.Text;
import net.minecraft.util.math.Box;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.math.MathHelper;
import net.minecraft.registry.Registries;
import net.minecraft.client.network.ClientPlayerEntity;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Unique;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Locale;

/**
 * Restores a simple lock‑on system for the local player.  Viewers can cycle 
 * through nearby entities of a given type and instruct the player to walk 
 * toward the selected target.  Enhancements include immediate cache 
 * refreshes and better handling of empty filters and lists.
 */
@Mixin(ClientPlayerEntity.class)
public abstract class ClientPlayerEntityLockOnMixin {
    @Unique private int chat_plays_mc$lockTargetId = -1;
    @Unique private static final double chat_plays_mc$RANGE = 64.0;
    @Unique private final List<Entity> chat_plays_mc$cachedTargets = new ArrayList<>();
    @Unique private int chat_plays_mc$targetIndex = -1;
    @Unique private int chat_plays_mc$cacheUpdateTicks = 0;
    @Unique private static final int chat_plays_mc$CACHE_UPDATE_INTERVAL = 20;
    // Camera tracking tuning
    @Unique private static final float chat_plays_mc$CAMERA_YAW_SPEED = 15.0f;   // deg per tick
    @Unique private static final float chat_plays_mc$CAMERA_PITCH_SPEED = 12.0f; // deg per tick

    @Inject(method = "tick", at = @At("TAIL"))
    private void chat_plays_mc$lockOnTick(CallbackInfo ci) {
        ClientPlayerEntity player = (ClientPlayerEntity)(Object)this;
        ClientWorld world = (ClientWorld) player.getWorld();
        if (!LockOnManager.isEnabled()) {
            chat_plays_mc$lockTargetId = -1;
            chat_plays_mc$targetIndex = -1;
            chat_plays_mc$cachedTargets.clear();
            chat_plays_mc$cacheUpdateTicks = 0;
            // Ensure global target is cleared as well
            LockOnManager.clearCurrentTarget();
            return;
        }
        String typeKey = LockOnManager.getEntityTypeKey();
        if (typeKey == null) {
            typeKey = "";
        }
        chat_plays_mc$cacheUpdateTicks++;
        boolean cacheExpired = chat_plays_mc$cacheUpdateTicks >= chat_plays_mc$CACHE_UPDATE_INTERVAL;
        if (chat_plays_mc$cachedTargets.isEmpty() || cacheExpired) {
            chat_plays_mc$updateTargetCache(world, player, typeKey);
            chat_plays_mc$cacheUpdateTicks = 0;
        }
        String command = LockOnManager.getTargetingCommand();
        if (command != null) {
            chat_plays_mc$handleTargetingCommand(command, player, world, typeKey);
            LockOnManager.clearTargetingCommand();
        }
        if (LockOnManager.isMovingToTarget()) {
            chat_plays_mc$handleMoveToTarget(player);
        }
        // New: always track camera toward current target while locked on
        if (chat_plays_mc$lockTargetId != -1) {
            chat_plays_mc$trackCameraToTarget(player);
        }
    }

    @Unique
    private void chat_plays_mc$updateTargetCache(ClientWorld world, ClientPlayerEntity player, String typeKey) {
        chat_plays_mc$cachedTargets.clear();
        Vec3d playerPos = player.getPos();
        Box searchBox = new Box(
                playerPos.subtract(chat_plays_mc$RANGE, chat_plays_mc$RANGE, chat_plays_mc$RANGE),
                playerPos.add(chat_plays_mc$RANGE, chat_plays_mc$RANGE, chat_plays_mc$RANGE)
        );
        for (Entity entity : world.getOtherEntities(player, searchBox)) {
            if (entity instanceof LivingEntity && !entity.isRemoved()) {
                if (chat_plays_mc$matchesEntityType(entity, typeKey)) {
                    chat_plays_mc$cachedTargets.add(entity);
                }
            }
        }
        chat_plays_mc$cachedTargets.sort(Comparator.comparingDouble(entity ->
                entity.getPos().squaredDistanceTo(playerPos)));
        if (chat_plays_mc$targetIndex >= chat_plays_mc$cachedTargets.size()) {
            chat_plays_mc$targetIndex = -1;
        }
    }

    @Unique
    private boolean chat_plays_mc$matchesEntityType(Entity entity, String typeKey) {
        if (typeKey.isEmpty()) return true;
        String entityId = Registries.ENTITY_TYPE.getId(entity.getType()).toString();
        String lowerKey = typeKey.toLowerCase(Locale.ROOT);
        return entityId.toLowerCase(Locale.ROOT).contains(lowerKey) ||
                Registries.ENTITY_TYPE.getId(entity.getType()).getPath().toLowerCase(Locale.ROOT).contains(lowerKey);
    }

    @Unique
    private void chat_plays_mc$handleTargetingCommand(String command, ClientPlayerEntity player, ClientWorld world, String typeKey) {
        if (chat_plays_mc$cachedTargets.isEmpty()) {
            chat_plays_mc$updateTargetCache(world, player, typeKey);
        }
        if (chat_plays_mc$cachedTargets.isEmpty()) {
            player.sendMessage(Text.literal("No valid targets found."), false);
            chat_plays_mc$lockTargetId = -1;
            chat_plays_mc$targetIndex = -1;
            return;
        }
        switch (command.toLowerCase(Locale.ROOT)) {
            case "nearest" -> {
                chat_plays_mc$targetIndex = 0;
                chat_plays_mc$setCurrentTarget(chat_plays_mc$cachedTargets.get(0), player);
            }
            case "next" -> {
                chat_plays_mc$targetIndex = (chat_plays_mc$targetIndex + 1 + chat_plays_mc$cachedTargets.size()) % chat_plays_mc$cachedTargets.size();
                chat_plays_mc$setCurrentTarget(chat_plays_mc$cachedTargets.get(chat_plays_mc$targetIndex), player);
            }
            case "previous", "prev" -> {
                chat_plays_mc$targetIndex = (chat_plays_mc$targetIndex - 1 + chat_plays_mc$cachedTargets.size()) % chat_plays_mc$cachedTargets.size();
                chat_plays_mc$setCurrentTarget(chat_plays_mc$cachedTargets.get(chat_plays_mc$targetIndex), player);
            }
            default -> player.sendMessage(Text.literal("Unknown lock‑on command: " + command), false);
        }
    }

    @Unique
    private void chat_plays_mc$setCurrentTarget(Entity target, ClientPlayerEntity player) {
        chat_plays_mc$lockTargetId = target.getId();
        // Also publish to the shared manager so other systems (HUD/Client tick) can access
        LockOnManager.setCurrentTarget(target);
        String targetName = target.getName().getString();
        double distance = player.getPos().distanceTo(target.getPos());
        player.sendMessage(Text.literal(String.format(Locale.ROOT,
                "Locked onto %s (%.1f blocks away)", targetName, distance)), false);
    }

    @Unique
    private void chat_plays_mc$handleMoveToTarget(ClientPlayerEntity player) {
        Entity target = chat_plays_mc$getCurrentTarget((ClientWorld) player.getWorld());
        if (target == null || target.isRemoved()) {
            LockOnManager.setMovingToTarget(false);
            player.sendMessage(Text.literal("Target lost."), false);
            chat_plays_mc$lockTargetId = -1;
            // Clear global target on loss
            LockOnManager.clearCurrentTarget();
            return;
        }
        Vec3d playerPos = player.getPos();
        Vec3d targetPos = target.getPos();
        double distance = playerPos.distanceTo(targetPos);
        if (distance <= LockOnManager.getTargetMoveDistance()) {
            LockOnManager.setMovingToTarget(false);
            player.sendMessage(Text.literal("Reached target."), false);
            return;
        }
        Vec3d direction = targetPos.subtract(playerPos).normalize();
        Vec3d velocity = direction.multiply(0.2);
        player.setVelocity(velocity.x, player.getVelocity().y, velocity.z);
        double yaw = Math.atan2(-direction.x, direction.z) * (180.0 / Math.PI);
        player.setYaw((float) yaw);
    }

    @Unique
    private void chat_plays_mc$trackCameraToTarget(ClientPlayerEntity player) {
        Entity target = chat_plays_mc$getCurrentTarget((ClientWorld) player.getWorld());
        if (target == null || target.isRemoved()) return;
        // Compute look vector from player's eyes to target's eye/center
        Vec3d eyePos = player.getEyePos();
        Vec3d tPos;
        if (target instanceof LivingEntity le) {
            tPos = le.getPos().add(0.0, le.getStandingEyeHeight(), 0.0);
        } else {
            tPos = target.getPos().add(0.0, Math.max(0.0f, target.getHeight() * 0.5f), 0.0);
        }
        Vec3d diff = tPos.subtract(eyePos);
        double horiz = Math.hypot(diff.x, diff.z);
        float desiredYaw = (float) Math.toDegrees(Math.atan2(-diff.x, diff.z));
        float desiredPitch = (float) Math.toDegrees(-Math.atan2(diff.y, horiz));

        float curYaw = player.getYaw();
        float curPitch = player.getPitch();
        float newYaw = chat_plays_mc$approachAngle(curYaw, desiredYaw, chat_plays_mc$CAMERA_YAW_SPEED);
        float newPitch = chat_plays_mc$approachAngle(curPitch, desiredPitch, chat_plays_mc$CAMERA_PITCH_SPEED);
        player.setYaw(newYaw);
        player.setPitch(MathHelper.clamp(newPitch, -90.0f, 90.0f));
    }

    @Unique
    private float chat_plays_mc$approachAngle(float from, float to, float maxStep) {
        float delta = MathHelper.wrapDegrees(to - from);
        float step = MathHelper.clamp(delta, -maxStep, maxStep);
        return from + step;
    }

    @Unique
    private Entity chat_plays_mc$getCurrentTarget(ClientWorld world) {
        if (chat_plays_mc$lockTargetId == -1) return null;
        return world.getEntityById(chat_plays_mc$lockTargetId);
    }
}